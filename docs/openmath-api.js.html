<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: openmath-api.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: openmath-api.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
"use strict"

// TODO: handle the case of this module running in the browser
// Import openmath-js for testing purposes
import { OM } from './openmath.js';

// Define the metavariable symbol to be used as an attribute key, and its corresponding value
const metavariableSymbol = OM.symbol('metavariable', 'SecondOrderMatching');
const trueValue = OM.string('true');

/**
 * This namespace creates an API by which this package can use a simple JavaScript
 * implementation of OpenMath to store and manipulate mathematical expressions.
 * @namespace OpenMathAPI
 */
const Exprs = {

    ////////////////////////////////////////////////////////////////////////////////
    // What is an expression?
    // Here are several basic functions for identifying, comparing, copying,
    // and doing basic manipulations of expressions.
    ////////////////////////////////////////////////////////////////////////////////

    /**
     * Returns true if and only if the given object is an OpenMath expression
     * @function isExpression
     * @param {object} expr - the object to test
     * @memberof OpenMathAPI
     */
    isExpression : (expr) => expr instanceof OM,

    /**
     * Return true iff the two expressions have the same type (e.g., both are
     * variables, or both are bindings, or both are function applications, etc.)
     * @function sameType
     * @param {OM} expr1 - first expression
     * @param {OM} expr2 - second expression
     * @memberof OpenMathAPI
     */
    sameType : (expr1,expr2) => expr1.type === expr2.type,

    /**
     * Returns a copy of an OpenMath expression
     * @function copy
     * @param {OM} expr - the expression to copy
     * @memberof OpenMathAPI
     */
    copy : (expr) => expr.copy(),

    /**
     * Compute whether the two expressions are structurally equal, and return true
     * or false.
     * @function equal
     * @param {OM} expr1 - first expression
     * @param {OM} expr2 - second expression
     * @memberof OpenMathAPI
     */
    equal : (expr1,expr2) => expr1.equals(expr2),

    /**
     * Replace one expression, wherever it sits in its parent tree, with another.
     * @function replace
     * @param {OM} toReplace - the expression to be replaced
     * @param {OM} withThis - the expression with which to replace it
     * @memberof OpenMathAPI
     */
    replace : (toReplace,withThis) => toReplace.replaceWith(withThis),

    ////////////////////////////////////////////////////////////////////////////////
    // Which expressions are variables?
    // How can I extract a variable's name, or build a variable from a name?
    // How can we find the variables inside another expression?
    ////////////////////////////////////////////////////////////////////////////////

    /**
     * Return true iff the given expression is a variable, false otherwise.
     * @function isVariable
     * @param {OM} expr - the expression to test
     * @memberof OpenMathAPI
     */
    isVariable : (expr) => expr.type === 'v',

    /**
     * Returns the variable's name, or null if it is not a variable.
     * @function getVariableName
     * @param {OM} variable - an OM instance of type variable
     * @memberof OpenMathAPI
     */
    getVariableName : (variable) => Exprs.isVariable(variable) ? variable.name : null,

    /**
     * Construct an expression that is just a variable, with the given name
     * @function variable
     * @param {string} name - the name of the new variable
     * @memberof OpenMathAPI
     */
    variable : (name) => OM.var(name),

    ////////////////////////////////////////////////////////////////////////////////
    // Sometimes we wish to create a new symbol in the language.
    // This may be a special type of expression, or a type of variable or string,
    // based on the language.  In OpenMath, it is a first-class citizen.
    ////////////////////////////////////////////////////////////////////////////////

    /**
     * Construct an expression that is a symbol with the given name.
     * The Content Dictionary is set to the name of this package.
     * @function symbol
     * @param {string} name - the name to use for the symbol
     * @memberof OpenMathAPI
     */
    symbol : (name) => OM.sym(name,'SecondOrderMatching'),

    /**
     * Helper function used when adding pairs to a constraint list.
     * Returns the list of variables that appear in a given expression.
     * @function getVariablesIn
     * @param {OM} expression - the expression to be checked
     * @returns a list containing any variables in the given expression
     * @memberof OpenMathAPI
     */
    getVariablesIn : (expression) => expression.descendantsSatisfying(Exprs.isVariable),

    ////////////////////////////////////////////////////////////////////////////////
    // Which expressions are function applications?
    // How can I build a function application expression,
    // or extract the list of children from an existing function application?
    ////////////////////////////////////////////////////////////////////////////////

    /**
     * Return true iff the given expression is a function application, false
     * otherwise.
     * @function isApplication
     * @param {OM} expr - the expression to test
     * @memberof OpenMathAPI
     */
    isApplication : (expr) => expr.type === 'a',

    /**
     * Make a function application expression from the given children.  For example,
     * to create f(x,y), pass [f,x,y].  All arguments are used as-is, not copied
     * first; do not pass copies you need elsewhere.
     * @function application
     * @param {OM[]} children - the children of the resulting application, the first
     *   of which should be the operator and the rest the operands
     * @memberof OpenMathAPI
     */
    application : (children) => OM.app(...children),

    /**
     * Return an array of the expression's children, in the order in which they
     * appear as children
     * @function getChildren
     * @param {OM} expr - the expression whose children should be returned
     * @memberof OpenMathAPI
     */
    getChildren : (expr) => expr.children,

    ////////////////////////////////////////////////////////////////////////////////
    // Which expressions bind variables?
    // How can I build such an expression?
    // If I have a binding expression, how can I extract its head, variables, or body?
    // How can I tell if one expression occurs free inside another?
    ////////////////////////////////////////////////////////////////////////////////

    /**
     * Return true iff the given expression is a binding expression, false
     * otherwise.
     * @function isBinding
     * @param {OM} expr - the expression to test
     * @memberof OpenMathAPI
     */
    isBinding : (expr) => expr.type === 'bi',

    /**
     * Make a binding expression from the given symbol, variables, and body.  For
     * example, to create Forall x, P, pass Forall, [x], and P.  All arguments are
     * used as-is, not copied first; do not pass copies you need elsewhere.
     * @function binding
     * @param {OM} symbol - the binding operator
     * @param {OM[]} variables - the array of bound variables
     * @param {OM} body - the body of the binding
     * @memberof OpenMathAPI
     */
    binding : (symbol,variables,body) => OM.bin(symbol,...variables,body),

    /**
     * Return the symbol/head/operator of the binding expression, if indeed the
     * given argument is a binding expression; return null otherwise.
     * @function bindingHead
     * @param {OM} expr - the expression whose operator is to be returned
     * @memberof OpenMathAPI
     */
    bindingHead : (binding) => Exprs.isBinding(binding) ? binding.symbol : null,

    /**
     * Return a list of the bound variables in the given expression, or null if the
     * given expression is not a binding one.
     * @function bindingVariables
     * @param {OM} binding - the expression whose bound variables are to be returned
     * @memberof OpenMathAPI
     */
    bindingVariables : (binding) => Exprs.isBinding(binding) ? binding.variables : null,

    /**
     * Return the body bound by a binding expression, or null if the given
     * expression is not a binding one.
     * @function bindingBody
     * @param {OM} binding - the expression whose body is to be returned (the
     *   original body, not a copy)
     * @memberof OpenMathAPI
     */
    bindingBody : (binding) => Exprs.isBinding(binding) ? binding.body : null,

    /**
     * Return true if a structural copy of the given inner (sub)expression occurs
     * free in the given outer expression.
     * @function occursFreeIn
     * @param {OM} outer - the expression in which to seek subexpressions
     * @param {OM} inner - the subexpression to seek
     * @memberof OpenMathAPI
     */
    occursFreeIn : (inner,outer) => outer.occursFree(inner),

    ////////////////////////////////////////////////////////////////////////////////
    // A metavariable is a variable that will be used for substitution.
    // How can I tell which variables are metavariables?
    // How can I mark a variable as being a metavariable, or clear such a mark?
    ////////////////////////////////////////////////////////////////////////////////

    /**
     * Tests whether the given variable has the metavariable attribute.
     * @function isMetavariable
     * @param {OM} variable - the variable to be checked
     * @memberof OpenMathAPI
     */
    isMetavariable : (variable) =>
        Exprs.isExpression(variable)
     &amp;&amp; ['v', 'sy'].includes(variable.type)
     &amp;&amp; variable.getAttribute(metavariableSymbol) != undefined
     &amp;&amp; variable.getAttribute(metavariableSymbol).equals(trueValue),

    /**
     * Marks a variable as a metavariable.
     * Does nothing if the given input is not an OMNode of type variable or type symbol.
     * @function setMetavariable
     * @param {OM} variable - the variable to be marked
     * @memberof OpenMathAPI
     */
    setMetavariable : (variable) => 
        Exprs.isExpression(variable) &amp;&amp; ['v', 'sy'].includes(variable.type) ?
        variable.setAttribute(metavariableSymbol, trueValue.copy()) : null,

    /**
     * Removes the metavariable attribute if it is present.
     * @function clearMetavariable
     * @param {OM} metavariable - the metavariable to be unmarked
     * @memberof OpenMathAPI
     */
    clearMetavariable : (metavariable) => metavariable.removeAttribute(metavariableSymbol),

};

export { OM, Exprs };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="OpenMathAPI.html">OpenMathAPI</a></li></ul><h3>Classes</h3><ul><li><a href="Constraint.html">Constraint</a></li><li><a href="ConstraintList.html">ConstraintList</a></li><li><a href="MatchingChallenge.html">MatchingChallenge</a></li></ul><h3>Global</h3><ul><li><a href="global.html#alphaConvert">alphaConvert</a></li><li><a href="global.html#alphaEquivalent">alphaEquivalent</a></li><li><a href="global.html#applyExpressionFunctionApplication">applyExpressionFunctionApplication</a></li><li><a href="global.html#betaReduce">betaReduce</a></li><li><a href="global.html#canApplyExpressionFunctionApplication">canApplyExpressionFunctionApplication</a></li><li><a href="global.html#CASES">CASES</a></li><li><a href="global.html#checkVariable">checkVariable</a></li><li><a href="global.html#getExpressionArgumentsFromApplication">getExpressionArgumentsFromApplication</a></li><li><a href="global.html#getExpressionFunctionFromApplication">getExpressionFunctionFromApplication</a></li><li><a href="global.html#getNewVariableRelativeTo">getNewVariableRelativeTo</a></li><li><a href="global.html#isExpressionFunction">isExpressionFunction</a></li><li><a href="global.html#isExpressionFunctionApplication">isExpressionFunctionApplication</a></li><li><a href="global.html#makeConstantExpression">makeConstantExpression</a></li><li><a href="global.html#makeExpressionFunction">makeExpressionFunction</a></li><li><a href="global.html#makeExpressionFunctionApplication">makeExpressionFunctionApplication</a></li><li><a href="global.html#makeImitationExpression">makeImitationExpression</a></li><li><a href="global.html#makeProjectionExpression">makeProjectionExpression</a></li><li><a href="global.html#replaceWithoutCapture">replaceWithoutCapture</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Oct 08 2020 11:38:19 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
